# Lab 3 User Environments

## 3.1 Introduction

- 本实验实现用户模式下的进程的正常运行

- 为此，需要加强内核的功能
  - 添加一些数据结构，来记录用户环境的一些信息
  - 创建一个单一的用户环境，并且加载一个程序来运行它
  - 完成用户环境作出的系统调用，以及处理用户环境产生的各种异常
- 本实验中，用户环境和用户进程等价

## 3.2 第一部分：用户环境和异常处理

- 文件inc/env.h包含JOS的用户环境的基本定义

  - 内核用struct Env来跟踪每个用户环境
  - 最初只创建一个环境，但是需要设计JOS使得它支持多个环境，实验4会用到这个功能，fork

- kern/env.c定义内核维护的与环境有关的三个全局变量

  ```c
  struct Env *envs = NULL;		// All environments
  struct Env *curenv = NULL;		// The current env
  static struct Env *env_free_list;	// Free environment list
  ```
  - JOS启动并运行后，envs指向代表系统中所有环境的Env结构数组
    - NENV定义在inc/env.h，表示最大环境数
    - envs数组会为每个环境分配一个Env结构的实例
  - env_free_list保存所有不活动的Env结构
    - 这种设计方便分配取消环境，只需要从空闲链表中插入或删除
  - curenv表示当前正在执行的环境
    - 初始化为NULL

### 3.2.1 表示环境的数据结构

- Env定义在inc/env.h，成员含义见代码注释

- JOS结合了线程和地址空间的概念？？？
  - 线程是由被保存的寄存器的值来定义（是进程还是线程，回忆csapp的上下文）
  - 地址空间由env_pgdir所指向的页目录表还有页表来定义
  - 为了运行一个用户环境，内核必须设置合适的寄存器的值以及合适的地址空间

### 3.2.2 分配表示环境的数组

- 修改Lab 2的mem_init代码，分配envs数组，映射到UENVS处，代码见仓库

### 3.2.3 创建并运行环境

- 编写kern/env.c来运行用户环境
- 现在没有文件系统，因此需要设置内核，使得内核能够加载嵌入在内核本身中的静态二进制映像
  - 正常情况下，都是从文件系统（磁盘）把可执行文件加载到内存中
  - 现在，ELF可执行映像被嵌入到内核中
- GNUmakefile文件在obj/usr/目录下生成了一系列二进制映像文件
  - ###
  - 在i386_init()函数中，可以看到运行这些二进制文件的代码，需要完成能够设置这些代码的运行用户环境的功能
- 代码见env.c
  - env_init
    - env_init_percpu是什么意思？？？
  - env_setup_vm
    - env_alloc
  - region_alloc
- 完成代码后，编译内核并在QEMU下运行
  - 系统会进入用户空间，并且开始执行hello程序，直到它做出一个系统调用指令int
  - 但是这个系统调用指令不能成功运行，因为JOS还没有设置相关硬件来实现从用户态向内核态的转换功能
  - 当CPU发现，它没有被设置成能够处理这种系统调用中断时，它会触发一个保护异常，然后这个保护异常也无法处理，从而又产生一个错误异常，然后又发现仍旧无法解决问题，所以最后放弃，也就是"triple fault"。接下来CPU会复位，系统会重启
- 在解决这个问题前，用gdb调试器检查一下程序进入用户模式时做了什么
  - 在函数env_pop_tf处设置断点，然后执行到断点，再单步执行到iret指令
  - 通过info register命令，可以把每一步的寄存器信息打印出来
  - 发现iret指令前后，cs寄存器发生变化，从存放内核代码段选择符，到存放用户代码段选择符

### 3.2.4 处理中断和异常

- 这时，用户空间中的第一个int $ 0x30系统调用指令已经死胡同：一旦处理器进入用户模式，就无法退出
  - 实现异常和系统调用处理，以便内核有可能从用户模式代码中恢复对处理器的控制
- 在继续实验之前，需要了解一下x86的异常中断机制

### 3.2.5 受保护的控制，它们的切换的基础

- 异常(Exception)和中断(Interrupts)都是“受到保护的控制转移方法”，都会使处理器从用户态转移为内核态。
  - 中断指的是由外部异步事件引起的处理器控制权转移，比如外部I/O设备发送来的中断信号
  - 异常是由于当前正在运行的指令所带来的同步的处理器控制权的转移，比如除零溢出异常
- 为了确保这些控制的转移能被保护起来，处理器的中断/异常机制通常被设计为：用户态代码无权选择内核中的代码从哪里开始执行
  - 处理器可以确保只有在某些条件下，才能进入内核态
  - 在x6上，有两种机制来提供这种保护

#### 3.2.5.1 中断向量表

- 处理器保证中断和异常只能引起内核进入到一些特定的程序入口

  - x86有256个中断和异常，每个都配备一个独特的中断向量（0~255）

- CPU使用中断向量作为中断向量表（IDT）的索引

  - 中断向量表由内核设置，放在内核空间
  - 中断向量找到一个中断向量表项（IDT描述符）

- 通过IDT描述符，处理器得知中断处理程序的一些信息，例如

  - 需要加载到eip寄存器的值，这个值指向了中断处理程序的位置

  - 需要加载到cs寄存器的值，这个值包含了中断处理程序的特权级（CPL）

#### 3.2.5.2 任务状态段

- 处理器还需要一个地方来保存，当异常/中断发生时，当前进程的用户态状态

  - 例如被中断的程序的EIP和CS寄存器的值
  - 这样的话，中断处理程序可以返回到原来的程序中
  - 这段内存也要保护起来，不能被用户态的程序所篡改，所以要放到内核权限的地址，因此放到内核栈

- 如何把控制切换到内核栈

  - 当一个x86处理器要处理一个中断，异常并且使运行特权级从用户态转为内核态时，会把它的栈指针切换成指向内核栈
  - 任务状态段（TSS）会记录内核堆栈所在的段的段描述符和地址
  - 处理器会把用户态的SS，ESP，EFLAGS，CS，EIP以及一个可选错误码等等这些值压入到这个堆栈上，然后加载中断处理程序的CS，EIP值，并且设置ESP，SS寄存器指向新的堆栈

  - 注意区分内核态（中断处理程序）的cs, eip和用户态（被中断的程序）的cs, eip

- 尽管TSS非常大，并且还有很多其他的功能，但是JOS仅仅使用它来定义处理器从用户态转向内核态所采用的内核堆栈，由于JOS中的内核态指的就是特权级0，所以处理器用TSS中的ESP0，SS0字段来指明这个内核堆栈的位置，大小

- 需要找到tss，JOS内核维护一个变量

  ```c
  static struct Taskstate ts;
  ```

  在trap_init_percpu() 函数中设置ts的成员

  - ts的SS0成员保存中断发生时要加载到ss寄存器的值，ss寄存器是保存tss段的段选择符的
  - ts的ESP0成员保存中断发生时要加载到esp寄存器的值，esp寄存器是栈顶指针
    - 相当于知道了段选择符和段内偏移，可以确定一个线性地址

### 3.2.6 异常和中断的类型

- 0~31号中断是同步中断，其中缺页中断是14号
- 31号以上的中断可以由int指令，或外部设备触发
  - 在JOS中，用48号中断作为系统调用中断

### 3.2.7 一个例子

- 假设处理器正在执行代码，此时遇到一条除以0的指令，处理器会做如下动作

  1. 根据ts的SS0和ESP0成员，将栈从用户栈切换到内核栈，也就是把ts的SS0成员和ESP0成员，分别加载到ss寄存器和esp寄存器

  2. 处理器在内核栈压入如下参数

     ```
     +--------------------+ KSTACKTOP             
     | 0x00000 | old SS   |     " - 4
     |          old ESP            |     " - 8
     |       old EFLAGS       |     " - 12
     | 0x00000 | old CS   |     " - 16
     |           old EIP            |     " - 20
     |        error code        |     " - 24 <---- ESP
     +-----------------------+  
     ```

  3. 除以0的异常中断号是0，处理器读取IDT的第0项，从中解析出cs: eip
  4. cs: eip处的异常处理函数执行
     
     - 段选择符 + 段内偏移，确定一个线性地址

- 这个过程，从哪里体现出“陷入内核”？？？是ss寄存器的DPL，还是cs寄存器的DPL？？？

- 压入的数据和Trapframe结构是一致的

### 3.2.8 嵌套异常和中断

- 处理器既可以接受来自内核态，也可以接受用户态的异常和中断

  - 如果用户态发生异常和中断，x86才会从用户栈切换到内核栈，然后将旧的寄存器状态压入内核栈，并通过IDT调用适当的异常处理程序
  - 如果内核态发生异常和中断，处理器会将更多的值压入同一个内核栈，通过这种方式来处理内核态引起的嵌套异常
    - 嵌套异常是实现保护的重要工具，在系统调用时可以看到这一点

- 发生嵌套异常时，内核栈的状态

  - 不推送错误代码的异常

    ```
    +-----------------------+ <---- old ESP
    |     old EFLAGS         |     " - 4
    | 0x00000 | old CS   |     " - 8
    |           old EIP            |     " - 12
    +-----------------------+             
    ```

    由于它不需要切换堆栈，因此不会保存旧的SS或ESP寄存器

  - 推送错误码的异常，处理器会像之前一样在旧eip之后立即推送错误代码

- 嵌套异常的一个注意点

  - 如果内核态下发生异常，且内核栈空间不足导致无法将旧状态入栈，则处理器无法采取措施处理这种情况，只能重启处理器自身，因此需要避免这种情况
    - 为什么仅仅完成env.c的代码会导致处理器不断重启，就是这个原因

### 3.2.9 设置IDT

- 现在需要设置iDT来处理中断向量0~31（处理器异常）

  - 在以后的实验中处理系统调用中断，也就是添加中断32~47

- 文件inc/trap.h和kern/trap.h包含中断和异常相关的定义

  - kern/trap.h包含内核态的一些定义
  - inc/trap.h包含用户态的一些定义

- 最后要实现的代码效果如下

  ```
               IDT                        trapentry.S              trap.c
     
  +-----------------+                        
  |   &handler1    |---------> handler1:          trap (struct Trapframe *tf)
  |                             |             		// do stuff      {
  |                             |             		call trap             	// handle the exception/interrupt
  |                             |             		// ...        			}
  +-----------------+
  |   &handler2    |--------> handler2:
  |                             |            	  	// do stuff
  |                             |            	  	call trap
  |                             |            	  	// ...
  +-----------------+
                 .
                 .
                 .
  +-----------------+
  |   &handlerX    |--------> handlerX:
  |                             |                	// do stuff
  |                             |                	call trap
  |                             |               	// ...
  +-----------------+
  ```

### 3.2.10 处理中断的流程

- 当执行了一条指令后，cs和eip寄存器包含下一条要执行的指令的分段地址；在处理那条指令前，控制单元会检查运行前一条指令时是否发生了中断或异常，如果有，那么操作系统的中断控制流程如下（参考《深入理解Linux内核》第4章）

  1. 确定和这个中断/异常关联的中断向量
     - IDT的初始化在trap.c的trap_init，建立起了中断处理函数和中断向量对应关系，而trap_init在i386_init被调用
     - 每个中断或异常都有自己的中断处理函数，在trapentry.S中通过宏 TRAPHANDLER 和 TRAPHANDLER_NOEC 来定义一个中断处理函数
     - 宏定义 SETGATE 设置IDT表项，具体实现见代码注释
     - 参数num是中断向量吗？？？

  2. 从idtr寄存器读取IDT的基地址，并在IDT中找到第i项
  3. 从gdtr寄存器读取GDT的基地址，并从IDT项中读取出段选择符和段内偏移，段选择符找到段描述符，进而确定段起始地址，再加上段内偏移，找到中断处理函数
     - IDT项见mmu.h的Gatedesc
  4. 比较特权级
  5. 如果有特权级变化，需要切换到内核栈，如何切换见3.2.5.2
  6. 如果中断处理程序执行完后还要执行这条指令，就把引起异常的指令地址加载到cs和eip寄存器，使得这条指令能被再次执行
     - 有些异常需要在处理结束后再次执行引起异常的指令，例如缺页异常
  7. 在内核栈中保存被中断的程序的eflags, cs和eip寄存器的值
  8. 如果异常产生了一个硬件错误码，也把它压入内核栈中
     - 此时内核栈的结构见3.2.7
  9. 把IDT的第i项的段描述符和段内偏移字段加载到cs和eip寄存器，他们是中断处理程序的逻辑地址
     - 把中断处理程序的逻辑地址写入cs和eip寄存器，下一条指令才能执行它们
     - 中断处理程序如何执行

- 中断处理程序的执行流程

  - 执行th0，它会把参数0入栈，然后调用\_alltraps
    - 为什么参数num要入栈？？？
  - \_alltraps保存上下文，也就是保存寄存器的值到内核栈中
    - ss, esp, eflags, cs, eip, err这些寄存器的值已经由处理器压入内核栈
    - _alltraps把段寄存器es, ds和通用寄存器的值压入内核栈
    - 这些寄存器的值，也就是上下文，刚好是一个Trapframe结构，是被中断的函数的寄存器值
  - alltraps() 调用trap()
    - trap()会调用dispatch_trap()，根据中断向量的不同进行不同的处理，这是第二部分的实验

  - trap()调用env_run()，恢复被中断的程序的上下文，返回用户态，继续执行被中断的程序
    - env_run()调用env_pop_tf()，它会取出来当前环境的env_tf成员，恢复当前环境的寄存器的值

- 实现的代码见 trapentry.S 和 trap.c 
  - 需要在trapentry.S文件中为在inc/trap.h文件中的每一个trap加入一个入口指令
  - 需要修改trap_init() 来初始化IDT，使表项指向定义在trapentry.S中的入口指针

### 3.2.11 一些问题和回答

1. 为什么不能用同一个处理程序处理所有异常/中断，而是要每个异常/中断都有自己的中断处理函数？

   - 不同的异常/中断可能需要不同的处理方式，比如有些异常是代表指令有错误，则不会返回被中断的命令；而有些中断可能只是为了处理外部IO事件，此时执行完中断函数还要返回到被中断的程序中继续运行

   ###

## 3.3 第二部分 页故障，断点异常和系统调用

- 现在的内核已经具有基本的异常处理能力，这部分实验要对其进行优化，以提供依赖于异常处理的操作系统原语

### 3.3.1 处理页故障

- 页面错误异常对应的中断向量是14（T_PGFLT）
- 当页面故障发生时，导致故障的线性地址会被存储到寄存器cr2中
- trap.c的函数page_fault_handler() 用于处理缺页异常
- Exercises: 修改trap_dispatch函数，使得系统能够把缺页异常引导到page_fault_handler() 上执行
  - 修改完成后，运行make grade，应该能够成功运行faultread, falutreadkernel, faultwrite, faultwritekernel测试程序
  - 在实现系统调用时，还需要对这里继续修改

### 3.3.2 断点异常

- 断点异常对应的中断向量是3（T_BRKPT）
- 用于允许开发人员在代码中插入断点，这种插入是通过用特殊的1字节int3软中断临时替换相关的指令实现的
- Exercises: 修改trap_dispatch()，使得断点异常发生时，能触发kernel/monitor.c中的monitor函数
  - 修改完成后，运行make grade，应该能够正确运行brakpoint测试程序
- 一些问题和回答
  - ###

### 3.3.3 系统调用

- 用户进程调用系统调用时，处理器进入内核态，内核执行适当的代码以执行系统调用，然后恢复用户进程
- 用户进程通过什么指令和中断号进入内核态
  - 在JOS内核中，使用int指令，使得处理器中断
  - 使用int $0x30作为系统调用中断，T_SYSCALL值为48（0x30），作为中断向量
  - 中断0x30不会由硬件生成，这就不会出现用户代码生成而引起歧义？？？
- 用户进程如何指定要执行哪个系统调用
  - 应用程序在寄存器中传递系统调用号和系统调用参数
    - 这样就不用查询用户栈了
    - 系统调用号唯一标识系统调用，存放在%eax
    - 系统调用参数最多五个，存放在%edx, %ecx, %ebx, %edi和%esi
    - 内核将返回值存放在%eax
  - lib/syscall.c中已经写好了用于调用系统调用的汇编代码，需要通过阅读来理解系统调用
- Exercises: 在内核中为中断向量T_SYSCALL添加一个处理程序
  - 修改kern/trapentry.S和kern/trap.c的trap_init()
    - 在kern/trapentry.S中声明T_SYSCALL的中断处理函数，和之前为其它中断号做的一样
    - 在trap_init() 中做th_syscall() 的函数声明，并给th_syscall() 注册
  - 修改trap_dispatch()，来处理系统调用中断
    - 使用适当的参数来调用kern/syscall.c中的syscall()，然后把返回值放在%eax传给用户程序
  - 修改kern/syscall.c的syscall()
    - 如果系统调用号不合法，要确保syscall()返回-E_INVAL
    - 所有的系统调用都列在inc/syscall.h
  - 测试代码
    - 通过命令make run-hello，运行usr/hello程序，应该能做到在控制台上打印出"hello world"，然后在用户模式下导致缺页异常
    - 还需要成功运行testbss测试程序
  - 完成后，整个调用链为trap_dispatch -> kern/syscall.c的syscall -> kern/syscall.c的sys_cputs -> cprintf -> lib/syscall.c的sys_cputs -> lib/syscall.c的syscall

### 3.3.4 用户态的启动

- 用户程序真正开始运行的地方是lib/entry.S
  - 该文件中，会先进行一些设置
  - 然后调用lib/libmain.c中的libmain() 函数
  - libmain() 调用umain，这个程序就是user/hello.c中被调用的函数
    - 之前hello.c程序只会打印"hello, world"，然后就会页异常，原因就是打印当前环境时，thisenv->env_id这条语句，thisenv没有被正确初始化指向当前环境
    - 现在已经初始化了thisenv的值，再运行就不会报错了
- Exercises: 补全libmain()
  - 关键是获取当前环境
  - 重新启动内核，会发现可以打印出来"i am environment 00001000"

### 3.3.5 页异常和内存保护

- 内存保护的功能是，防止由于用户程序崩溃对操作系统带来的破坏和影响

- 操作系统依赖于硬件的支持来实现内存保护

  - 硬件始终知晓哪些虚拟地址有效，哪些无效

  - 当程序试图访问一个无效地址，或者一个超出它访问权限的地址时，处理器会在这个指令处终止，并触发异常，切换到内核态

    - 如果异常可修复，会在内核态下修复这个异常，并继续运行

    - 否则，程序不会继续运行

- 一个可修复异常的例子：可自动扩展的堆栈
  - 初始情况下，内核栈只有一个页的大小
  - 如果压入栈的内容超过了一个页的大小，会触发异常，在内核态下再分配一些页供内核栈使用，程序便可以继续运行
- 系统调用在内存保护方面的问题
  - 大多数系统调用接口让用户程序传递一个指针参数给内核？？？
    - 这些指针指向用户缓冲区
    - 系统调用可以在执行的时候解引用这些指针
  - 存在的两个问题
    - 需要区分内核的页异常和用户程序的页异常
      - 如果是内核操作自己的数据结构时出现页异常，这是内核bug，进行异常处理时要中断整个内核
      - 如果是解引用由用户程序传来的指针时出现页异常，需要记录这种页异常是用户程序带来的
    - 内核比用户程序有更高的内存访问权限
      - 用户程序可能传一个指针参数给系统调用，这个指针指向的其余是内核可以读写，但是用户程序不能
      - 此时内核不能解析这个指针，否则会泄露内核信息？？？
  - 需要检查所有由用户程序传递来的指针指向的空间，来解决上述两个问题
    - 检查这个地址是否在用户地址空间部分，并且能通过页表进行内存操作
- Exercises: 修改kern/trap.c，使得能够发现，内核态下发生页异常时，trap.c会panic
  - 为了能够判断页异常是发生在用户态还是内核态，需要检查tf_cs的低几位
    - tf_cs的后两位表示当前代码段的权限
  - 阅读kern/pmap.c的user_mem_assert，并且实现user_mem_check
    - 判断环境env是否有权限访问虚拟地址[va, va + len)
  - 修改kern/syscall.c去检查输入参数
    - 实现sys_cputs，判断用户在终端输入的参数是否可以正常访问
  - 启动内核后，运行user/buggyhello程序，用户环境可以被销毁，内核不可以panic
  - 代码完成后，调用顺序为sys_cputs -> user_mem_assert -> user_mem_assert -> env_destroy -> 页异常